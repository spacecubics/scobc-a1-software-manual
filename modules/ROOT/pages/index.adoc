= SC-OBC Module A1 Software Manual

== Setting Up the Development Environment for SC-OBC Module A1

=== Prepare the Software

==== Target Platform

This guide is focused on *Ubuntu 24.04 x86_64* systems.

You can use any of the following setups:

* A PC with Ubuntu installed
* A system container (e.g., Incus)
* A virtual machine (e.g., QEMU, VirtualBox, VMware)
* WSL2 (build only, no flashing)
** Due to issues finding executables, the Zephyr Project doesn’t currently support application flashing using the WSL2.

For Windows or macOS users, refer to link:https://docs.zephyrproject.org/latest/develop/getting_started/index.html[the official Zephyr documentation].

==== Install Required Dependencies

[INFO]
======
This section is mostly the same as Zephyr official documentation.
======

===== Update your system

[source, bash]
----
$ sudo apt update && sudo apt upgrade
----

===== Install dependencies

[source, bash]
----
$ sudo apt install --no-install-recommends git cmake ninja-build gperf \
  ccache dfu-util device-tree-compiler wget \
  python3-dev python3-pip python3-setuptools python3-tk python3-wheel xz-utils file \
  make gcc gcc-multilib g++-multilib libsdl2-dev libmagic1
----

==== Get Zephyr and Python Requirements

===== Create your working directory

[source, bash]
----
$ mkdir -p ~/myproject && cd ~/myproject
----

===== Install Python venv package

[source, bash]
----
$ sudo apt install python3-venv
----

===== Create a new virtual environment

[source, bash]
----
$ python3 -m venv ~/myproject/.venv
----

===== Activate the virtual environment

[source, bash]
----
$ source ~/myproject/.venv/bin/activate
----

===== Install West

[source, bash]
----
$ pip install west
----

===== Clone the SC-OBC Module A1 sample repository using West

[source, bash]
----
$ cd ~/myproject
$ west init -m https://github.com/spacecubics/scobc-a1-sample.git
$ west update
$ west zephyr-export
----

===== Install Python requirements

[source, bash]
----
$ pip install -r zephyr/scripts/requirements.txt
----

==== Install Zephyr SDK

[source, bash]
----
$ west sdk install
----

==== Install the udev rules

Install the udev rules, which allow you to flash most Zephyr boards as a regular user.

[source, bash]
----
$ sudo cp ~/zephyr-sdk-[VERSION]/sysroots/x86_64-pokysdk-linux/usr/share/openocd/contrib/60-openocd.rules \
          /etc/udev/rules.d
$ sudo udevadm control --reload
----

== Device Tree

=== What is the Device Tree?

The *Device Tree* is a data structure originally developed as part of the Open Firmware specification (IEEE 1275), where it was used to describe the hardware layout of systems such as PowerPC-based workstations and servers.

This concept was later adopted and popularized in the Linux kernel, particularly for platforms like ARM and PowerPC, to enable the kernel to support multiple hardware configurations without requiring separate builds or hardcoded board-specific initialization.

A Device Tree describes the physical components of a system — such as *CPUs, memory, buses, and peripheral devices* — in a structured and hierarchical format.
This hardware description is typically written in a human-readable *Device Tree Source (DTS)* file, which is compiled into a binary *Device Tree Blob (DTB)* using the *Device Tree Compiler (DTC)*.
The DTB is then passed to the Linux kernel at boot time to guide hardware initialization.

=== Device Tree in Zephyr

In Zephyr, the Device Tree model was adopted to improve scalability and modularity across a wide variety of supported boards and SoCs.
Unlike in Linux, where the DTB is loaded at runtime, Zephyr parses the DTS at build time to generate static configuration headers.

This enables lightweight and efficient hardware abstraction, while still benefiting from the flexibility and reusability that Device Tree provides.

* *Hardware Abstraction*
** Describes hardware outside application code, reducing hardware-specific logic in C files.

* *Portability*
** A single source tree can support multiple hardware variants by simply switching DTS files.

* *Maintainability*
** Easier to add support for new boards or SoCs without modifying existing drivers or core logic.

* *Scalability*
** Makes it easier to manage families of devices with similar but not identical hardware configurations.

=== Common Usage of the Device Tree in Zephyr

In Zephyr, the Device Tree is used to:

* Define and configure peripherals like UART, I2C, SPI, GPIO, CAN, and more.
* Bind drivers to hardware automatically based on compatible strings.
* Pass hardware parameters to applications via macros generated from the DTS (e.g., base addresses, interrupts, labels).
* Manage multiple board variants using overlays.

=== Basic Structure

A Device Tree is structured like a filesystem, with nodes and properties:
Nodes represent hardware components (e.g., `/cpu`, `/memory`, `/soc/gpio@40020000`)

Properties are key-value pairs describing attributes like addresses, interrupts, clocks, and more.

This introduction is a starting point.
For deeper understanding, consider reviewing the link:https://docs.zephyrproject.org/latest/build/dts/index.html[official Zephyr device tree documentation].

